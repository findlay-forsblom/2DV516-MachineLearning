import mathimport numpy as npclass KNeighborsClassifier:  def __init__(self, n_neighbors):    self.n_neighbors = n_neighbors  def fit(self, X, y):    self.X = X    self.y = y  def predict(self, Xtest):    self.ypred = []    rows = Xtest.shape[0]    numOfRows = self.X.shape[0]    for rowXtest in range(rows):      self.closestNeigbors = []      xtest1 = Xtest[rowXtest, 0]      xtest2 = Xtest[rowXtest,1]            for row in range(numOfRows):          x1 = self.X[row,0]          x2 = self.X[row,1]                    # calculates the euclidean distance for the point and each row          # it then creates a new 2darray where the distance between the points are saved          euclidDist = math.sqrt((x1 - xtest1) **2 + (x2 -xtest2) **2)          arr = [x1,x2, euclidDist, self.y[row]]          self.closestNeigbors.append(arr)          numOfColumns = len(self.closestNeigbors)      self.closestNeigbors = np.array(self.closestNeigbors).reshape(numOfColumns, 4)     #sorts the 2d array based on the closest neighbors       self.closestNeigbors = self.closestNeigbors[self.closestNeigbors[:, 2].argsort()]      self.closestNeigbors = self.closestNeigbors[:self.n_neighbors, :]          y = self.closestNeigbors[:,-1]      y = y.tolist()          # takes the most frequent number from the array      pred = max(y, key = y.count)      self.ypred.append((pred))    self.ypred = np.array(self.ypred)      return self.ypred  def getTraningerrors(self):        X = np.copy(self.X)        y = self.y        ypred = self.predict(X)        errors = 0                for value in range(len(ypred)):            if ypred[value] != y[value]:                errors +=1        return errors    